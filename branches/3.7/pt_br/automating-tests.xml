<?xml version="1.0" encoding="utf-8" ?>

<chapter id="automating-tests">
  <title>Automatizando Testes</title>

  <para>
    Até mesmo bons programadores cometem erros. A diferença entre um bom
    programador e um mau programador é que o bom programador usa testes
    para detectar seus erros o mais rápido possível. Quanto mais cedo você
    testar, mais chances você tem de encontrar um grande erro e terá o menor
    custo para achá-lo e corrigi-lo. Isso explica por que deixar para testar
    o software depoius de lançá-lo é tão complicado. A maioria dos erros não
    são pegos e o custo para corrigir os que você conseguir encontrar é tão 
    grande quanto para realizar a triagem com os erros, pois você não pode   
    se dar ao luxo de corrigir todos.
  </para>

  <para>
    <indexterm><primary>Teste Unitário</primary></indexterm>

    Testar com o PHPUnit não é uma atividade totalmente diferente do que você
    realmente deveria estar fazendo. É apenas uma maneira diferente de fazê-lo.
    A diferença está entre <emphasis>testar</emphasis>, isto é, checar se o 
    seu programa se comporta como esperado, e <emphasis>realizar uma bateria
    de testes</emphasis>, fragmentos de código rodando para testar automaticamente
    fragmentos de código de partes (inidades) do software. Estes fragmentos
    de código são chamados de testes unitários.
  </para>

  <para>
    Neste capítulo nós iremos partir de um simpes codificação de testes baseado
    em <literal>prints</literal> para um teste totalmente automatizado. Imagine-nos
    pedindo pra testar um <literal>array</literal> embutido no códogo PHP. Uma
    das funcionalidades para teste é a função <literal>count()</literal>. Para um
    novo array criado, nós esperamos que a função <literal>count()</literal> retorne
    o valor <literal>0</literal>. Depois de adicionarmos um elemento, a função
    <literal>count()</literal>  dever retornar <literal>1</literal>.
    O arqivo <xref linkend="automating-tests.examples.array-test.php" /> mostra o 
    que queremos testar.
  </para>

  <example id="automating-tests.examples.array-test.php">
    <title>Testando operação com vetores</title>
    <programlisting><![CDATA[<?php
$fixture = array();
// é esperado que $fixture seja vazio.

$fixture[] = 'element';
// é esperado que $fixture tenha um elemento.
?>]]></programlisting>
  </example>

  <para>
    Uma maneira muito simples de verificar se estamos obtendo os resultados
    esperados é "printar" o resultado do <literal>count()</literal> antes e 
    depois de adicionar o elemento (veja 
    <xref linkend="automating-tests.examples.array-test2.php" />).
    Se nós recebemos <literal>0</literal> e, em seguida, <literal>1</literal>, 
    a função <literal>count()</literal>, e consequentemente o <literal>array</literal>,
    estão se comportando conforme esperado.
  </para>

  <example id="automating-tests.examples.array-test2.php">
    <title>Usando print para testar operação com array</title>
    <programlisting><![CDATA[<?php
$fixture = array();
print count($fixture) . "\n";

$fixture[] = 'element';
print count($fixture) . "\n";
?>]]></programlisting>
    <screen>0
1</screen>
  </example>

  <para>
    Agora, nós gostariamos de mover para os testes o que o manual nos sugere
    ser necessário para interpretarmos um teste para que possa ser executado 
    automaticamente. No arquivo <xref linkend="automating-tests.examples.array-test3.php" />
    escrevemos o comparativo entre o valor experado e o valor atual dentro do
    código de teste e escrevemos <literal>ok</literal> se os valores são iguais.
    Se houver diferença veremos uma mensagem <literal>not ok</literal> e saberemos
    que o teste falhou.
  </para>

  <example id="automating-tests.examples.array-test3.php">
    <title>Comparando valores esperados e atual no teste de operação com vetores.</title>
    <programlisting><![CDATA[<?php
$fixture = array();
print count($fixture) == 0 ? "ok\n" : "not ok\n";

$fixture[] = 'element';
print count($fixture) == 1 ? "ok\n" : "not ok\n";
?>]]></programlisting>
    <screen>ok
ok</screen>
  </example>

  <para>
    <indexterm><primary>Assertions (Afirmações)</primary></indexterm>

    Agora vamos decompor a compraração dos valores esperado e a atual de uma
    função que retorna uma excessão há uma discrepância 
    (<xref linkend="automating-tests.examples.array-test4.php" />). Este nos dá
    dois benefícios: os testes escritos tornam-se fáceis e nós apenas recebemos
    a saída quando há um falha no teste.
  </para>

  <example id="automating-tests.examples.array-test4.php">
    <title>Usando uma função de afirmação para testar operações com vetor</title>
    <programlisting><![CDATA[<?php
$fixture = array();
assertTrue(count($fixture) == 0);

$fixture[] = 'element';
assertTrue(count($fixture) == 1);

function assertTrue($condition)
{
    if (!$condition) {
        throw new Exception('Afirmação falsa.');
    }
}
?>]]></programlisting>
  </example>

  <para>
    <indexterm><primary>Teste Automatizado</primary></indexterm>

    Agora o teste está completamente automatizado. Em vez de apenas
    <emphasis>testarmos</emphasis>, como fizemos na nossa primeira versão,
    temos nesta versão um <emphasis>teste automatizado</emphasis>.
  </para>

  <para>
    O ganho de se usar testes automatizados é que você comente menos erros. 
    Enquanto que seu código ainda não está perfeito, mesmo com excelentes testes, 
    você irá gostar de ver uma redução drástica nos defeitos uma vez que  
    iniciar os testes automatizados. Testes automáticos te dão justificativas
    de confiabilidade do seu código. Você pode usar esta confiança para dar
    saltos mais largos no desenho do software (Refactoring), ter um melhor
    convívio com seus companheiros de equipe (Cross-Team Tests), melhorar o
    relacionamento com seus clientes e ir para casa toda noite com a prova que
    o sistema está melhor do que você o encontrou de manhã, graças aos seus esforços.
  </para>
</chapter>
