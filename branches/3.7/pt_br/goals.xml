<?xml version="1.0" encoding="utf-8" ?>

<chapter id="goals">
  <title>Objetivos do PHPUnit</title>

  <para>
    Até agora, nós temos apenas dois testes para o <literal>array</literal> embutido
    e a função  <literal>count()</literal>. Quando começamos a testar as numerosas
    funções <literal>array_*()</literal> que o PHP oferece, nós precisaremos escrever
    um teste para cada uma delas. Poderíamos escrever a estrutra para todos estes
    testes a partir do zero. Entretanto, é muito melhor escrever apenas uma infra-estrutura
    testes e então escrever apenas uma parte única para cada deste. Esta é a
    infra-estrutura do PHPUnit.
  </para>

  <para>
    Um framework como o PHPUnit pode resolver um conjunto de restrições, alguns
    dos quais parecem sempre em conflito uns com os outros. Simultaneamente, os 
    testes devem ser:
  </para>

  <variablelist>
    <varlistentry>
      <term><emphasis>Fácil de ler e escrever.</emphasis></term>
      <listitem>
        <para>
          Se é difícil aprender como escrever testes, os desenvolvedores não irão
          aprender a escrevê-los.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Fácilidade na escrita.</emphasis></term>
      <listitem>
        <para>
          Se os testes não são fáceis de escrever, os desenvenvolvedores não
          irão fazê-los.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Facilidade na leitura.</emphasis></term>
      <listitem>
        <para>
          Códigos de testes não deveriam conter sobrecargas estranhas de modo
          que os testes não podem se perder no ruído que os sercam.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Facilidade na execução.</emphasis></term>
      <listitem>
        <para>
          Os testes devem rodar com um simples toque de um botão e apresentar
          seus resultados de modo claro e que não seja ambíguo.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Rápido para executar.</emphasis></term>
      <listitem>
        <para>
          Os testes devem rodar rápido, de modo que eles possam ser executados
          centenas ou milhares de vezes em um único dia.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Isolamento.</emphasis></term>
      <listitem>
        <para>
          Um teste não pode afetar outro. Se há mudança na ordem em que os testes são rodados,
          o resultado destes tests não podem mudar.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Composição.</emphasis></term>
      <listitem>
        <para>
          Devemos ser capazes de rodar juntos qualquer número ou combinação de testes.
          Este é um corolário do isolamento.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>
    Há dois empasses principais entre estas restrições:
  </para>

  <variablelist>
    <varlistentry>
      <term><emphasis>Fácil de aprender a escrever versus fácilidade na escrita.</emphasis></term>
      <listitem>
        <para>
          Os testes, geralmente, não requerem toda a flexibilidade de uma  
          linguagem de programação. Muitas ferramentas de testes fornecem 
          sua própria linguagem que inclui apenas o mínimo de características 
          necessária para escrever os testes. O resultado dos testes são fáceis
          de ser lido e escrito porque eles não possuem ruído para destraí-lo 
          com o conteúdo destes testes. Entretanto, aprender ainda outra linguagem
          de programação e escolher as ferramentas de programação é incoveniente e 
          irá deixar o programador confuso.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><emphasis>Isolamento versus rapidez na execução.</emphasis></term>
      <listitem>
        <para>
          Se você quer que os resultados de um teste não possua efeito no resultado
          de outro teste, cada teste de ve criar um estado completo do seu universo
          antes de começar a executar e, após a finalização dos testes, retorná-lo
          ao estado inicial. Entretanto, criar um universo pode levar muito tempo:
          por exemplo, conectar um banco de dados e inicializá-lo em um estado
          conhecido usando dados reais.
        </para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>
    O PHPUnit tentará resolver estes conflitos usando o PHP como a linguagem
    de testes. Às vezes todo o poder do PHP é um exageiro para escrever pequenos
    testes, mas usando PHP aproveitamos toda experiência e ferramentas dos progamadores
    já existente. Já que estamos tentado convencer os testadores relutantes, 
    é importante diminuir as barreiras para se escrever testes iniciais.
  </para>

  <para>
    O PHPUnit peca na parte do isolamento em execuções rápidas. Testes isolados
    são valiosos porque promovem um retorno de alta qualidade. Você não recebe
    um relatório com um monte de falhas nos testes, que foram realmente causados
    porque um dos testes inicializados na suíte de testes falhou e deixou o seu
    universo de testes confuso para o restante dos testes. Esta orientação para
    testes isolados incentiva projetos com um grande número de objetos simples.
    Cada objeto pode ser isolado e testado rapidamente. O resultado são bons projeto
    e testes rápidos.
  </para>

  <para>
    O PHPUnit assume que mais testes com sucesso e não vale a pena reportar
    os detalhes dos testes bem sucedidos. Quando um teste falha, é importante
    anotar este fato e reportá-lo. A grande maioria dos tesets devem executar 
    com sucesso e não vale a pena comentá-lo, exceto para contabilizar o número
    de testes que foram executados. Este é uma suposição do que realmente é construído
    nas classes de relatório, e não dentro do código do PHPUnit. Então o resultado
    da execução de um teste é reportado e você vê quantos testes foram executados, 
    mas apenas verá detalhes para os testes que falharam.
  </para>

  <para>
    Os testes deverão ser refinados, testando um aspecto de um objeto. Por isso,
    num primeiro momento um teste irá falhar, executando a suspenção dos testes, 
    e o PHPUnit irá reportar as falhas. Esta é a arte de testar rodando pequenos testes.
    Refinar os testes melhora a concepção do sistema como um todo.
  </para>

  <para>
    Quando você testa um objeto com o PHPUnit, você vai fazê-lo somente pelos 
    métodos públicos do ohjeto. Testes baseados apenas sobre o comportamento
    público visível lhe encoraja a encarar e resolver difíceis de design, antes 
    que os resultados de um projeto pobre afetem, em larga escala, o sistema.
  </para>
</chapter>
