<?xml version="1.0" encoding="utf-8" ?>

<chapter id="testing-practices">
  <title>A Prática de Testes</title>

  <blockquote>
    <attribution>Erich Gamma</attribution>
    <para>
      Você sempre pode escrever mais testes. Contudo, você irá descobrir facilmente
      que apenas uma fração destes testes que você pensou é realmente útil. 
      O que você quer é escrever testes que falham, mesmo que você acredite que 
      eles deveriam funcionar, ou mesmo testes de sucesso embora você pense que
      eles devem falhar. Outra maneira de pensar é em termos de custo-benefício.
      Você quer escrever testes que irá lhe devolver informações úteis.
    </para>
  </blockquote>

  <section id="testing-practices.during-development">
    <title>Durante o Desenvolvimento</title>

    <para>
      <indexterm><primary>Refatorando</primary></indexterm>

      Quando você precisa fazer uma mudança em uma estrutura interna do seu software,
      você está trabalhando para fazê-lo de uma forma que seja fácil de entender e 
      tenha uma manutenção mais barata, desde que não altere o seu comportamento desejável, 
      uma suíte de testes é de valor inestimável na aplicação desses chamados Refactorings de segurança. 
      Caso contrário, você pode não notar a quebra do sistema enquanto você está realizando a reestruturação.
    </para>

    <para>
      As seguintes condições irão ajudá-lo a melhorar o seu código e a apresentação do  
      seu projeto, enquanto estiver usanto testes unitários para verificar que os passos
      da refatoração de transformação são, de fato, comportamento de preservação e não introduz erros:
    </para>

    <orderedlist>
      <listitem>
        <para>Todos os testes unitários executaram corretamente.</para>
      </listitem>

      <listitem>
        <para>O código comunica os seus princípios de design.</para>
      </listitem>

      <listitem>
        <para>O código não contém redundâncias.</para>
      </listitem>

      <listitem>
        <para>O código possui o mínimo de classes e arquivos para ser executado.</para>
      </listitem>
    </orderedlist>

    <para>
      Quando você precisar adicionar novas funcionalidades em seus sistema, 
      escreva os testes primeiro. Então, você vai desenvolvendo enquanto roda os testes.
      Esta pratica será discutida em detalhes no próximo capítulo.
    </para>
  </section>

  <section id="testing-practices.during-debugging">
    <title>Durante a Depuração</title>

    <para>
      Quando você começa a reportar defeitos, você pode ser tomado por um impulso 
      de corrigir o defeito o mais rápido possível. Experiências mostram que este
      impulso pode não atendê-lo bem; é provável que a correção deste defeito faça
      com que outro defeito apareça.
    </para>

    <para>
      Você pode segurar seus impulsos em checar, fazendo o seguinte:
    </para>

    <orderedlist>
      <listitem>
        <para>
          Verifique se você pode reproduzir o erro.
        </para>
      </listitem>

      <listitem>
        <para>
          Encontre a manifestação primitiva do defeito no código.
          Por exemplo, se um número aparece incorretamente numa saída, encontro o 
          objeto que está computando este número.
        </para>
      </listitem>

      <listitem>
        <para>
          Escreva um teste automático que agora gere falha, mas será bem sucedido
          quando o defeito for corrigido.
        </para>
      </listitem>

      <listitem>
        <para>
          Corrija o erro.
        </para>
      </listitem>
    </orderedlist>

    <para>
      Encontrar a menor reprodução confiável de um defeito dá-lhe a oportunidade
      para examinar realmente a causa do defeito. O teste que você escreve irá melhorar
      as chances de que, quando você corrigir o defeito, você realmente irá corrigi-lo,
      porque o novo teste reduzir a probabilidade de ruína da correção quando novas
      alterações forem sendo escritas. Todos estes testes você escreveu antes
      de reduzir a probabilidade de inadivertidamente causar um problema diferente.
    </para>

    <blockquote>
      <attribution>Benjamin Smedberg</attribution>
      <para>
        Testes unitários oferecem muitas vantages:
        <itemizedlist>
          <listitem><para>Teste dá aos autores de código e revisores a confiança de que os patches produzam os resultados corretos.</para></listitem>
          <listitem><para>Casos de teste de autoria é um ímpeto bom para desenvolvedores para descobrir casos extremos.</para></listitem>
          <listitem><para>Teste fornece uma boa maneira de chamar regressões rapidamente, e para se certificar de que nenhuma regressão será repetida duas vezes.</para></listitem>
          <listitem><para>Os testes unitários são exemplos de trabalho sobre como usar uma API e podem ajudar significativamente os esforços de documentação.</para></listitem>
        </itemizedlist>
        Em geral, testes unitários integrados fazem com que o custo e o risto 
        de qualquer mudança individual diminua. Ele vai permitir o projeto fazer [...]
        grandes melhorias de arquitetura [...] rapidamente e de forma confiável.
      </para>
    </blockquote>
  </section>
</chapter>
